import { selectLimit, selectPage, setPage } from "@store/slices/infiniteScrollSlice";
import { useCallback, useMemo, useRef } from "react";
import { useDispatch, useSelector } from "react-redux";
// the useInfiniteScroll can take as a props any useQuery generated by RTK
export function useInfiniteScroll(useGetQuery) {
	// getting the current state from redux store.
	// You can pass it as a props if you wish or manage it with a useState
	//! you need to use the global state (store) for optimistique update
	const dispatch = useDispatch();
	const page = useSelector(selectPage);
	const limit = useSelector(selectLimit);

	// this is the original recommandation from @phryneas.
	// It ensures that the api store is fully managing the caching, invalidating...
	const lastQueryResponse = useGetQuery({
		page: page - 1,
		limit,
	});

	// console.log("lastQueryResponse");
	// console.log(lastQueryResponse);
	const currentQueryResponse = useGetQuery({
		page,
		limit,
	});

	// console.log("currentQueryResponse");
	// console.log(currentQueryResponse);
	const nextQueryResponse = useGetQuery({
		page: page + 1,
		limit,
	});

	// console.log("nextQueryResponse");
	// console.log(nextQueryResponse);
	const combinedData = useMemo(() => {
		const arr = Array.from({ length: limit * (page + 1) });

		// console.log("Fetching data for pages:", {
		// 	lastPage: lastQueryResponse.data?.page,
		// 	currentPage: currentQueryResponse.data?.page,
		// 	nextPage: nextQueryResponse.data?.page,
		// });
		for (const data of [lastQueryResponse.data, currentQueryResponse.data, nextQueryResponse.data]) {
			if (data) {
				// console.log("data");
				// console.log(data);
				const offset = (data.page - 1) * data.limit;
				arr.splice(offset, data.data.length, ...data.data);
			}
		}
		const isNotFullyEmpty = arr.some((value) => value !== undefined);
		return isNotFullyEmpty ? arr : [];
	}, [currentQueryResponse.data, lastQueryResponse.data, limit, nextQueryResponse.data, page]);

	const { page: remotePage = 1, hasNextPage = false } = currentQueryResponse?.data || {};

	const isFetching = useMemo(
		() => lastQueryResponse?.isFetching || currentQueryResponse?.isFetching || nextQueryResponse?.isFetching,
		[currentQueryResponse?.isFetching, lastQueryResponse?.isFetching, nextQueryResponse?.isFetching]
	);
	const isLoading = useMemo(
		() => lastQueryResponse?.isLoading || currentQueryResponse?.isLoading || nextQueryResponse?.isLoading,
		[currentQueryResponse?.isLoading, lastQueryResponse?.isLoading, nextQueryResponse?.isLoading]
	);
	const isError = useMemo(
		() => lastQueryResponse?.isError || currentQueryResponse?.isError || nextQueryResponse?.isError,
		[currentQueryResponse?.isError, lastQueryResponse?.isError, nextQueryResponse?.isError]
	);
const error = useMemo(
	() => lastQueryResponse?.error || currentQueryResponse?.error || nextQueryResponse?.error,
	[lastQueryResponse?.error, currentQueryResponse?.error, nextQueryResponse?.error]
);

	// this part of the code is managing the scroll up and down event.
	// make sure you are using an intersection observer and not the scroll event.
	// it will save you hours of debuging :)
	// this part of the code can be abstracted in a useOnScreen custom hook

	const lastIntObserver = useRef(null);
	const lastRowRef = useCallback(
		(node) => {
			if (isFetching) return;
			if (lastIntObserver.current) lastIntObserver.current.disconnect();
			lastIntObserver.current = new IntersectionObserver((entries) => {
				if (entries[0].isIntersecting && hasNextPage && page === remotePage) {
					dispatch(setPage(page + 1));
				}
			});
			if (node) lastIntObserver.current.observe(node);
		},
		[hasNextPage, isFetching, page, remotePage, dispatch]
	);

	const firstIntObserver = useRef(null);
	const firstRowRef = useCallback(
		(node) => {
			if (isFetching) return;
			if (firstIntObserver.current) firstIntObserver.current.disconnect();
			firstIntObserver.current = new IntersectionObserver((entries) => {
				if (entries[0].isIntersecting && page > 1) {
					dispatch(setPage(page - 1));
				}
			});
			if (node) firstIntObserver.current.observe(node);
		},
		[isFetching, page, dispatch]
	);

	return {
		combinedData,
		lastRowRef,
		firstRowRef,
		isFetching,
		isLoading,
    isError,
    error
	};
}
